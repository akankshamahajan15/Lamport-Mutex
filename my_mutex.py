# -*- generated by 1.0.12 -*-
import da
PatternExpr_284 = da.pat.TuplePattern([da.pat.ConstantPattern('ack'), da.pat.FreePattern('c2'), da.pat.BoundPattern('_BoundPattern288_')])
PatternExpr_354 = da.pat.TuplePattern([da.pat.ConstantPattern('request'), da.pat.FreePattern('c2'), da.pat.FreePattern('p')])
PatternExpr_380 = da.pat.TuplePattern([da.pat.ConstantPattern('release'), da.pat.FreePattern(None), da.pat.FreePattern('p')])
PatternExpr_492 = da.pat.TuplePattern([da.pat.ConstantPattern('done')])
PatternExpr_497 = da.pat.BoundPattern('_BoundPattern499_')
PatternExpr_500 = da.pat.TuplePattern([da.pat.FreePattern(None), da.pat.TuplePattern([da.pat.FreePattern(None), da.pat.FreePattern(None), da.pat.BoundPattern('_BoundPattern506_')]), da.pat.TuplePattern([da.pat.ConstantPattern('done')])])
_config_object = {'channel': 'fifo', 'clock': 'lamport'}
import sys
import time

class P(da.DistProcess):

    def __init__(self, procimpl, props):
        super().__init__(procimpl, props)
        self._PReceivedEvent_0 = []
        self._PReceivedEvent_3 = []
        self._events.extend([da.pat.EventPattern(da.pat.ReceivedEvent, '_PReceivedEvent_0', PatternExpr_284, sources=None, destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.ReceivedEvent, '_PReceivedEvent_1', PatternExpr_354, sources=None, destinations=None, timestamps=None, record_history=None, handlers=[self._P_handler_353]), da.pat.EventPattern(da.pat.ReceivedEvent, '_PReceivedEvent_2', PatternExpr_380, sources=None, destinations=None, timestamps=None, record_history=None, handlers=[self._P_handler_379]), da.pat.EventPattern(da.pat.ReceivedEvent, '_PReceivedEvent_3', PatternExpr_492, sources=[PatternExpr_497], destinations=None, timestamps=None, record_history=True, handlers=[])])

    def setup(self, s, nrequests, logps, **rest_511):
        super().setup(s=s, nrequests=nrequests, logps=logps, **rest_511)
        self._state.s = s
        self._state.nrequests = nrequests
        self._state.logps = logps
        self._state.q = set()
        self._state.min_t = ('request', 0, 0)

    def run(self):
        start_cpu_time = time.time()

        def task():
            pass
        for i in range(self._state.nrequests):
            self.sendr()
        for i in range(self._state.nrequests):
            self.canEnterCS()
            self.send(('incs', self.logical_clock(), self._id), to=self._state.logps)
            self.mutex(task)
            self.send(('outcs', self.logical_clock(), self._id), to=self._state.logps)
            self.releaser()
        self.send(('done', self._id), to=self.parent())
        end_cpu_time = time.time()
        total_cpu_time = (end_cpu_time - start_cpu_time)
        self.send(('cputime', total_cpu_time, self._id), to=self._state.logps)
        super()._label('_st_label_489', block=False)
        _st_label_489 = 0
        while (_st_label_489 == 0):
            _st_label_489 += 1
            if PatternExpr_500.match_iter(self._PReceivedEvent_3, _BoundPattern506_=self.parent(), SELF_ID=self._id):
                _st_label_489 += 1
            else:
                super()._label('_st_label_489', block=True)
                _st_label_489 -= 1

    def sendr(self):
        super()._label('request', block=False)
        c = self.logical_clock()
        self.send(('request', c, self._id), to=self._state.s)
        self._state.q.add(('request', c, self._id))

    def canEnterCS(self):
        min = sys.maxsize
        for (tag, c, p) in self._state.q:
            if ((p == self._id) and (min > c)):
                self._state.min_t = ('request', c, p)
                min = c
        super()._label('_st_label_250', block=False)
        p = c2 = None

        def UniversalOpExpr_252():
            nonlocal p, c2
            for (_ConstantPattern256_, c2, p) in self._state.q:
                if (_ConstantPattern256_ == 'request'):
                    if (not (((c2, p) == (min, self._id)) or ((min, self._id) < (c2, p)))):
                        return False
            return True
        p = c2 = None

        def UniversalOpExpr_277():
            nonlocal p, c2
            for p in self._state.s:

                def ExistentialOpExpr_282(p):
                    nonlocal c2
                    for (_, _, (_ConstantPattern299_, c2, _BoundPattern302_)) in self._PReceivedEvent_0:
                        if (_ConstantPattern299_ == 'ack'):
                            if (_BoundPattern302_ == p):
                                if (c2 > min):
                                    return True
                    return False
                if (not ExistentialOpExpr_282(p=p)):
                    return False
            return True
        _st_label_250 = 0
        while (_st_label_250 == 0):
            _st_label_250 += 1
            if (UniversalOpExpr_252() and UniversalOpExpr_277()):
                _st_label_250 += 1
            else:
                super()._label('_st_label_250', block=True)
                _st_label_250 -= 1

    def mutex(self, task):
        task()

    def releaser(self):
        super()._label('release', block=False)
        p = self._id
        for x in {('request', c, self._id) for (_ConstantPattern328_, c, _ConstantPattern332_) in self._state.q if (_ConstantPattern328_ == 'request') if (_ConstantPattern332_ == self._id)}:
            self._state.q.remove(x)
            break
        self.send(('release', self.logical_clock(), self._id), to=self._state.s)

    def _P_handler_353(self, c2, p):
        self._state.q.add(('request', c2, p))
        self.send(('ack', self.logical_clock(), self._id), to=p)
    _P_handler_353._labels = None
    _P_handler_353._notlabels = None

    def _P_handler_379(self, p):
        for x in {('request', c, p) for (_ConstantPattern396_, c, _BoundPattern399_) in self._state.q if (_ConstantPattern396_ == 'request') if (_BoundPattern399_ == p)}:
            self._state.q.remove(x)
            break
    _P_handler_379._labels = None
    _P_handler_379._notlabels = None
